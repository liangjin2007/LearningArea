# 数理逻辑算法

## 数学部分
#### 偏微分方程归纳总结

#### 数学方法
- 由伽利略最速降线问题，引出泛函求解方法。
  - 由变量t给出函数x(t), x(t)可以是向量函数
  - 由函数x(t)，给出拉氏函数L(t, x(t), x'(t))
  - 由拉氏函数给出的泛函
```
\begin{aligned}
Lagrange \ Function: L(t,x(t), x'(t))) \\
Simple \ Functional:A[f] = \int L(t,x(t),x'(t)) dt \\
Euler-Lagrange \ Equation: -\frac{d}{dt}\frac{\partial L}{\partial x'}+\frac{L}{x} = 0 \\
The \ Solution \ to \ minA[f] \ is \ the \ solution \ of \ E-L \ Equation. 
\end{aligned}
```
<a href="https://www.codecogs.com/eqnedit.php?latex=\begin{aligned}&space;Lagrange&space;\&space;Function:&space;L(t,x(t),&space;x'(t)))&space;\\&space;Simple&space;\&space;Functional:A[f]&space;=&space;\int&space;L(t,x(t),x'(t))&space;dt&space;\\&space;Euler-Lagrange&space;\&space;Equation:&space;-\frac{d}{dt}\frac{\partial&space;L}{\partial&space;x'}&plus;\frac{L}{x}&space;=&space;0&space;\\&space;The&space;\&space;Solution&space;\&space;to&space;\&space;minA[f]&space;\&space;is&space;\&space;the&space;\&space;solution&space;\&space;of&space;\&space;E-L&space;\&space;Equation.&space;\end{aligned}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\begin{aligned}&space;Lagrange&space;\&space;Function:&space;L(t,x(t),&space;x'(t)))&space;\\&space;Simple&space;\&space;Functional:A[f]&space;=&space;\int&space;L(t,x(t),x'(t))&space;dt&space;\\&space;Euler-Lagrange&space;\&space;Equation:&space;-\frac{d}{dt}\frac{\partial&space;L}{\partial&space;x'}&plus;\frac{L}{x}&space;=&space;0&space;\\&space;The&space;\&space;Solution&space;\&space;to&space;\&space;minA[f]&space;\&space;is&space;\&space;the&space;\&space;solution&space;\&space;of&space;\&space;E-L&space;\&space;Equation.&space;\end{aligned}" title="\begin{aligned} Lagrange \ Function: L(t,x(t), x'(t))) \\ Simple \ Functional:A[f] = \int L(t,x(t),x'(t)) dt \\ Euler-Lagrange \ Equation: -\frac{d}{dt}\frac{\partial L}{\partial x'}+\frac{L}{x} = 0 \\ The \ Solution \ to \ minA[f] \ is \ the \ solution \ of \ E-L \ Equation. \end{aligned}" /></a>

##### 欧拉-拉格朗日
- 欧拉-拉格朗日方程 Euler-Lagrange PDEs
  - 薄膜曲面membrane surface
  - 薄盘曲面thin-plate surface
  - 极小化曲率曲面
这个方程是泛函中非常重要的方程，也是非常经典的能量泛函极小化的方法，不论在物理还是计算机领域，应用非常广泛。所谓能量泛函，是指微分的范数平方再积分。
它的最初的思想来源于微积分中“可导的极值点一定是稳定点（临界点）”。它的精髓思想在于：假定当前泛函的解已知，那么这个解必然使得泛函取得最小值（假定是最小值）。换言之，只要在泛函中加入任何扰动，都会使泛函的值变大，所以扰动为0的时候，就是泛函关于扰动的一个极小值。所以当扰动的能量趋近于0，泛函关于扰动的导数也是0。关键是扰动如何表示。答案是扰动用一个很小的数e乘上一个连续函数。当e趋近于0,意味着扰动也趋近于0。所以当a为0的时候，泛函对a的导数也为0。这就非常巧妙的把对函数求导的问题转化成了一个单因子变量求导的问题。这就是这个思想的伟大之处。


#### 偏微分方程归纳总结

- Covariance Matrix
- Gram Matrix: AA^T
- Jensen不等式 
  - 如果f是凸函数，X是随机变量，那么E[f(X)] >= f(E[X])
- EM
  - [博客](http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html)
  - EM是一种解决存在隐含变量优化问题的有效方法
  - 目标：独立同分布样本{x(i)}, 每个样本隐含一个类别z, 要使得p(x, z)最大。
- Earth Mover's Distance(EMD)
  - [github](https://github.com/wmayner/pyemd)
- MSE
  - keras
  ```
  return K.mean(K.square(y_pred - y_true), axis=-1)
  ```
- PSNR
  - 10*log10(square(L)/MSE)
   - Structural Similarity (SSIM) Index in Image Space(SSIM)
  - tf.image.ssim
  - [skimage](http://scikit-image.org/docs/dev/auto_examples/transform/plot_ssim.html)
  - [github](https://github.com/jterrace/pyssim)
  - f(l(x,y)*c(x,y)*s(x,y))

- Luminance
  - mean intensity : l(x) = mean(x) = sum(x)/N

- move to center
  - x-l(x) means project x onto the hyperplane of sum(x) = 0.
  
- Contrast
  - standard deviation(root of squared variance) as contrast. Use unbiased estimation 
  - contrast(x) = sqrt(sum(square(x-l(x)))/(N-1))
  
- normalize
  - (x-l(x))/contrast(x)

- l(x,y) range in 0~1 and avoid numeric overflow
  - (2*l(x)*l(y)+C)/(square(l(x))+square(l(y))+C

- structure comparison
  - correlation(inner product) correlation(x, y) = sum((xi-l(x))*(yi-l(y))/(N-1)
  - s(x,y) = (correlation(x, y)+C)/((contrast(x)*contrast(y))+C)

- spearman ranking
  - 度量预测数组和true数组的排序情况。 这个度量在结合mse的情况下，可以用来度量，预测数组的相对排序情况。
  ```
  def spearman_rank2(y_true, y_pred):
    # tf.argsort(values)
    # tf.gather(values, tf.argsort(values))
    
    n = y_pred.shape[0]
    a = [0.0]*n
    b = [0.0]*n
    for i in range(n):
        a[i] = (i, y_pred[i])

    for i in range(n):
        b[i] = (i, y_true[i])
     
    c = np.array(a, dtype=[('x', int), ('y', float)])
    d = np.array(b, dtype=[('x', int), ('y', float)])

    c.sort(order='y')
    d.sort(order='y')

    for i,v in enumerate(c.tolist()):
        a[v[0]] = i
    for i,v in enumerate(d.tolist()):
        b[v[0]] = i
    a = np.array(a).astype(np.float32)
    b = np.array(b).astype(np.float32)

    return 1.0 - (np.sum(np.square(a-b))*6.0/(n**2*n-n))
  ```

## 算法部分
#### 二叉搜索树
- 二叉搜索树例子
![例子](https://github.com/liangjin2007/data_liangjin/blob/master/BST.jpg?raw=true)

- C++例子
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 * TreeNode *tree = ***;
 */
```
#### 红黑树
一棵有n个内结点的红黑树的高度至多为2lg(n+1)
二叉树的一种
[参考链接](https://blog.csdn.net/haidao2009/article/details/8076970)

- 红黑树定义
1. 每个结点或是红色的，或是黑色的
2. 根节点是黑色的
3. 每个叶结点（NIL）是黑色的
4. 如果一个节点是红色的，则它的两个儿子都是黑色的。
5. 对于每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑色结点。

- 红黑树例子
   ![红黑树例子](https://github.com/liangjin2007/data_liangjin/blob/master/redblacktree.png?raw=true "红黑树例子")

- C++例子
   - std::map
#### 哈希表（散列表）
- 哈希表
   - 哈希值函数 hash_function(key)
   - 一个大vector存指针
   - 用来解决hash值冲突的链表
- 哈希表例子
   ![哈希表例子](https://github.com/liangjin2007/data_liangjin/blob/master/hashtable.jpg?raw=true "哈希表例子")

- C++例子
   - std::unordered_map

#### Two Sum

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> finder;
        for(int i = 0; i < nums.size(); ++i){
            int num = nums[i];
            auto f = finder.find(target-num);
            if(f != finder.end()){
                return vector<int>{f->second, i};
            }else{
                finder.insert({num, i});
            }
        }
    }
};
```
#### Two Sum of Ordered Vector
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int i = 0, j = numbers.size()-1;
        while(i < j){
            int sum = numbers[i]+numbers[j];
            if(sum == target)
                return vector<int>{i+1, j+1};
            else if(sum < target)
                i++;
            else
                j--;
        }
    }
};
```

#### Two Sum of BST
```
class Solution {
public:
    void middleOrderTraverse(TreeNode* root, vector<TreeNode*>& orderedValues){
        if(root->left)
            middleOrderTraverse(root->left, orderedValues);
        if(root)
            orderedValues.push_back(root);
        if(root->right)
            middleOrderTraverse(root->right, orderedValues);
    }
    
    bool findTarget(TreeNode* root, int k) {
        vector<TreeNode*> orderedValues;
        middleOrderTraverse(root, orderedValues);
        
        int i = 0, j = orderedValues.size()-1;
        while(i < j){
            int sum = orderedValues[i]->val + orderedValues[j]->val;
            if(sum == k) return true;
            else if(sum < k)i++;
            else j--;
        }
        return false;
    }
};
```
#### Add Two Numbers By Lists
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addThreeNumbers(ListNode* l1, ListNode* l2, int& increment){
        if(!l1 && !l2 && increment == 0)
            return 0;
        
        int sum = 0;
        if(l1) sum += l1->val;
        if(l2) sum += l2->val;
        sum += increment;
        
        int digit = sum % 10;
        ListNode *res = new ListNode(digit);
        increment = sum/10;
        
        return res;
    }
    
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int increment = 0;
        vector<ListNode*> nodes;
        while(l1 || l2 || increment){
            auto n = addThreeNumbers(l1, l2, increment);
            if(!n)
                break;
            nodes.push_back(n);
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        
        if(nodes.size() > 0){
            for(int i = 0; i < nodes.size()-1; i++)
                nodes[i]->next = nodes[i+1];

            nodes.back()->next = 0;
            
            return nodes[0];
        }
        
        return 0;
    }
};
```
![流程图](https://github.com/liangjin2007/data_liangjin/blob/master/workflow.jpg?raw=true)


#### 字符串处理之——不重复最长字串
```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> dict(256, -1);
        int maxLen = 0;
        int start = -1;
        for(int i = 0; i < s.length(); i++){
            int c = s[i];
            if(dict[c] > start)
                start = dict[c];
            dict[c] = i;
            maxLen = max(maxLen, i-start);
        }
        return maxLen;
    }
};
```

#### 求中位数 Median of Two Sorted Arrays 思路融合两个已排序数组
```
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> merged;
        int size1 = nums1.size(), size2 = nums2.size();
        merged.reserve(size1+size2);
        int i = 0, j = 0;
        while(i < size1 && j < size2){
            if(nums1[i] <= nums2[j]){
                merged.push_back(nums1[i]);
                i++;
            }
            else{
                merged.push_back(nums2[j]);
                j++;
            }
        }
        
        for(int k = i; k < size1; k++){
            merged.push_back(nums1[k]);
        }
        for(int k = j; k < size2; k++){
            merged.push_back(nums2[k]);
        }
        
        int middle = (merged.size()-1)/2;
        if(merged.size() % 2 == 0)
            return 0.5*(merged[middle]+merged[middle+1]);
        return merged[middle]*1.0;
    }
};
```

### 模拟退火算法
对于一个自变量为x的目标函数为f(x)的极小化问题， 设fk = f(xk), fk+1 = f(xk+1)，对x随机采样及用一个概率值决定是否决定用它




## 图形学部分

## 计算机视觉部分
